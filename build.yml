/*const Log = []
function updatelog() {
const logTextElement = document.getElementById('log_text');
Log.forEach(entry => {
logTextElement.textContent += JSON.stringify(entry) + '\n';
});
}
*/
function controlleduaf() {
        // Simulate allocation of an object
        let obj = { data: "abcdefghijklmnopqrstuvwxyz" };

        // Reference to the object
        let ref = obj;

        console.log("Before freeing:", ref.data); // Output: important data

        // Simulate freeing the object
        obj = null;

        try {
            // Attempt to use the reference after the object is "freed"
            console.log("After freeing:", ref.data); // This should fail in a true use-after-free
        } catch (e) {
            alert("Error:", e.message); // Catch any errors
        }
    }
/*
function ComplexOverflow() {
    let largeString = "A".repeat(1000000); // 1 million A's
    let bufferArray = [];
    let nestedArray = [];
    let obj = {};
    let counter = 0;
    let counterr = 0;

alert("Running //String conc Debug")         
        // String concatenation
        largeString += largeString;
        if (largeString.length > 100000000) {
            largeString = "A".repeat(1000000);
        }
alert("Running //Aray Buffer Allocation Debug")
        // Array buffer allocation
        bufferArray.push(new ArrayBuffer(1000000));
        if (bufferArray.length > 1000) {
            bufferArray = [];
        }
alert("Running /Nested Arrays")
        // Nested arrays
        nestedArray.push([]);
        if (nestedArray.length > 1000) {
            nestedArray = [];
        }

 alert("Running //Reload Debug")
        counterr++;
        if (counterr >= 100) {
            location.reload();
        }
        // Object property expansion
        obj[counter] = "A".repeat(1000);
        counter++;
        if (counter > 10000000) {
            obj = {};
            counter = 0;
        }
    }
}
*/
function ComplexOverflow() {
    let largeString = "A".repeat(1000000); // 1 million A's
    let bufferArray = [];
    let nestedArray = [];
    let obj = {};
    let counter = 0;
    let counterr = 0;

    function stringConcatenation() {
        largeString += largeString;
        if (largeString.length > 100000000) {
            largeString = "A".repeat(1000000);
        }
    }

    function arrayBufferAllocation() {
        bufferArray.push(new ArrayBuffer(1000000));
        if (bufferArray.length > 1000) {
            bufferArray = [];
        }
    }

    function handleNestedArrays() {
        nestedArray.push([]);
        if (nestedArray.length > 1000) {
            nestedArray = [];
        }
    }

    function handleObjectPropertyExpansion() {
        obj[counter] = "A".repeat(1000);
        counter++;
        if (counter > 10000000) {
            obj = {};
            counter = 0;
        }
    }

    function checkReload() {
        counterr++;
        if (counterr >= 100) {
            location.reload();
        }
    }

    alert("Running //String conc Debug");
    stringConcatenation();

    alert("Running //Array Buffer Allocation Debug");
    arrayBufferAllocation();

    alert("Running /Nested Arrays");
    handleNestedArrays();

    alert("Running //Reload Debug");
    checkReload();

    handleObjectPropertyExpansion();
}








let MTestClassesArray = [];

class MTestClass {
    constructor() {}
}

const create_1000_objects = () => {
    let counter = 0;
    controlleduaf()
    while (true) {
        // Simulate allocation of an object
        let obj = { data: "important data" };

        // Reference to the object
        let ref = obj;

        console.log("Before freeing:", ref.data); // Output: important data

        // Simulate freeing the object
        obj = null;

        try {
            // Attempt to use the reference after the object is "freed"
            console.log("After freeing:", ref.data); // This should fail in a true use-after-free
        } catch (e) {
            console.log("Error:", e.message); // Catch any errors
        }
    
        counter++;
        if (counter >= 500) {
            location.reload();
        }
        for (let i = 0; i < 1000; i++) {
            MTestClassesArray.push(new MTestClass());
        }
        const text = `Total ${MTestClassesArray.length} MTestClass objects created`;
        document.getElementById('divMsg').innerHTML = text;
    }
}

function overflow_string() {
    let largeString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" // 1 million A's
    while (true) {
        largeString += largeString; // Double the size each time
        if (largeString.length > 1000000000) { // Adjust the threshold as needed
            largeString = "A".repeat(1000000); // Reset to prevent immediate crash
        }
    }
}
//updatelog()
